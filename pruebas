from app_inversiones.conexion import Conexion
from app_inversiones.models_db import get_valor_actual
from app_inversiones.models_api import get_neto_valor_actual

"""
def get_saldo_crypto(crypto_from, quantity_from):
    conectarSaldoTo = Conexion(f"SELECT SUM(cantidad_to) FROM investments WHERE moneda_to = '{crypto_from}';")
    saldo_to = conectarSaldoTo.res.fetchone()
    conectarSaldoTo.con.close()

    conectarSaldoFrom = Conexion(f"SELECT SUM(cantidad_from) FROM investments WHERE moneda_from = '{crypto_from}';")
    saldo_from = conectarSaldoFrom.res.fetchone()
    conectarSaldoFrom.con.close()

    saldo = saldo_to[0] - saldo_from[0]

    if saldo >= quantity_from:
        return True
    else:
        return False
    

crypto = "BTC"
asd = get_saldo_crypto(crypto, 15)
print(asd)


def get_last_id(registroFecha, registroHora):
    conectarId = Conexion(f"SELECT id FROM investments WHERE date = '{str(registroFecha)}' and time = '{str(registroHora)}';")
    id = conectarId.res.fetchone()
    conectarId.res.close()    
    print(id[0])

fecha = '2024-01-25'
hora = '19:33:28'

id = get_last_id(fecha, hora)


def get_valor_actual():
    #Toma todos los valores unicos de moneda_to de la db
    conectarMonedaTo = Conexion("SELECT DISTINCT moneda_to FROM investments;")
    monedas_to = conectarMonedaTo.res.fetchall()  # [('BTC',), ('ETH',), ('EUR',), ('SOL',), ('ADA',)]
    conectarMonedaTo.con.close()

    #Guarda la cantidad total de cada moneda de moneda_to en el dic crypto_quantity como par 'moneda': cantidad total
    crypto_quantity = {}
    for moneda in monedas_to:  #moneda = tupla ('BTC',)     
        if moneda[0] != 'EUR':  
            conectarMonedasToQuantity = Conexion(f"SELECT SUM(cantidad_to) FROM investments WHERE moneda_to = '{str(moneda[0])}';")
            crypto_quantity[moneda[0]] = conectarMonedasToQuantity.res.fetchone()[0]
            conectarMonedasToQuantity.con.close()


    #Toma todos los valores unicos de moneda_from de la db
    conectarMonedaFrom = Conexion("SELECT DISTINCT moneda_from FROM investments;")
    monedas_from = conectarMonedaFrom.res.fetchall()  
    conectarMonedaFrom.con.close()

    #Resta la cantidad total (suma de cantidades de cantidad_from) de cada moneda del diccionario para que en el diccionario queden las cantidades netas
    for moneda in monedas_from: #moneda = tupla ('BTC',) 
        if moneda[0] != 'EUR':
            for item in crypto_quantity:
                if item == moneda[0]: 
                    conectarMonedasFromQuantity = Conexion(f"SELECT SUM(cantidad_from) FROM investments WHERE moneda_from = '{str(moneda[0])}';")
                    crypto_quantity[item] -= conectarMonedasFromQuantity.res.fetchone()[0]
                    conectarMonedasFromQuantity.con.close()

    return crypto_quantity  #{'BTC': 5.0046, 'ETH': -3.551, 'SOL': 253.2116, 'ADA': 3366.9327}

get_valor_actual()


def get_status():
    conectarInvertido = Conexion("SELECT SUM(cantidad_from) FROM investments WHERE moneda_from = 'EUR';")
    invertido = conectarInvertido.res.fetchone()
    conectarInvertido.con.close()
    
    conectarRecuperado = Conexion("SELECT SUM(cantidad_to) FROM investments WHERE moneda_to = 'EUR';")
    recuperado = conectarRecuperado.res.fetchone()
    conectarRecuperado.con.close()
    
    valor_compra = float(invertido[0]) - float(recuperado[0])
    
    netos_crypto = get_valor_actual()  #{'BTC': 5.0046, 'ETH': -3.551, 'SOL': 253.2116, 'ADA': 3366.9327}
    
    valor_actual = 0
    for item in netos_crypto:
        valor_actual += get_neto_valor_actual(item, netos_crypto[item])
        print(valor_actual)

    return {"invertido": invertido[0], "recuperado": recuperado[0], "valor_compra": valor_compra, "valor_actual": valor_actual}

get_status()
"""